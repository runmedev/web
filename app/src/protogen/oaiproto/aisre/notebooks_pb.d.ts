// @generated by protoc-gen-es v2.4.0 with parameter "keep_empty_files=true,target=js+dts"
// @generated from file oaiproto/aisre/notebooks.proto (package oaiproto.aisre, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";
import type { Cell } from "../../runme/parser/v1/parser_pb";

/**
 * Describes the file oaiproto/aisre/notebooks.proto.
 */
export declare const file_oaiproto_aisre_notebooks: GenFile;

/**
 * @generated from message oaiproto.aisre.ListCellsRequest
 */
export declare type ListCellsRequest = Message<"oaiproto.aisre.ListCellsRequest"> & {
};

/**
 * Describes the message oaiproto.aisre.ListCellsRequest.
 * Use `create(ListCellsRequestSchema)` to create a new message.
 */
export declare const ListCellsRequestSchema: GenMessage<ListCellsRequest>;

/**
 * @generated from message oaiproto.aisre.ListCellsResponse
 */
export declare type ListCellsResponse = Message<"oaiproto.aisre.ListCellsResponse"> & {
  /**
   * @generated from field: repeated runme.parser.v1.Cell cells = 2;
   */
  cells: Cell[];
};

/**
 * Describes the message oaiproto.aisre.ListCellsResponse.
 * Use `create(ListCellsResponseSchema)` to create a new message.
 */
export declare const ListCellsResponseSchema: GenMessage<ListCellsResponse>;

/**
 * @generated from message oaiproto.aisre.GetCellsRequest
 */
export declare type GetCellsRequest = Message<"oaiproto.aisre.GetCellsRequest"> & {
  /**
   * @generated from field: repeated string ref_ids = 1;
   */
  refIds: string[];
};

/**
 * Describes the message oaiproto.aisre.GetCellsRequest.
 * Use `create(GetCellsRequestSchema)` to create a new message.
 */
export declare const GetCellsRequestSchema: GenMessage<GetCellsRequest>;

/**
 * @generated from message oaiproto.aisre.GetCellsResponse
 */
export declare type GetCellsResponse = Message<"oaiproto.aisre.GetCellsResponse"> & {
  /**
   * @generated from field: repeated runme.parser.v1.Cell cells = 1;
   */
  cells: Cell[];
};

/**
 * Describes the message oaiproto.aisre.GetCellsResponse.
 * Use `create(GetCellsResponseSchema)` to create a new message.
 */
export declare const GetCellsResponseSchema: GenMessage<GetCellsResponse>;

/**
 * @generated from message oaiproto.aisre.UpdateCellsRequest
 */
export declare type UpdateCellsRequest = Message<"oaiproto.aisre.UpdateCellsRequest"> & {
  /**
   * @generated from field: repeated runme.parser.v1.Cell cells = 1;
   */
  cells: Cell[];
};

/**
 * Describes the message oaiproto.aisre.UpdateCellsRequest.
 * Use `create(UpdateCellsRequestSchema)` to create a new message.
 */
export declare const UpdateCellsRequestSchema: GenMessage<UpdateCellsRequest>;

/**
 * @generated from message oaiproto.aisre.UpdateCellsResponse
 */
export declare type UpdateCellsResponse = Message<"oaiproto.aisre.UpdateCellsResponse"> & {
  /**
   * We want to provide the updated cells to the AI because the cells might have been modified by
   * the agent (e.g. ref_ids) might have been generated.
   *
   * @generated from field: repeated runme.parser.v1.Cell cells = 1;
   */
  cells: Cell[];
};

/**
 * Describes the message oaiproto.aisre.UpdateCellsResponse.
 * Use `create(UpdateCellsResponseSchema)` to create a new message.
 */
export declare const UpdateCellsResponseSchema: GenMessage<UpdateCellsResponse>;

/**
 * @generated from message oaiproto.aisre.NotebookServiceExecuteCellsRequest
 */
export declare type NotebookServiceExecuteCellsRequest = Message<"oaiproto.aisre.NotebookServiceExecuteCellsRequest"> & {
  /**
   * TODO(jlewi): Right now you the AI has to specify the IDs of the cells to execute. This means it
   * needs to use separate Update calls to set the code to execute. In the future, we may want to
   * allow the AISRE to issue a single execute request to update and execute.
   *
   * @generated from field: repeated string ref_ids = 1;
   */
  refIds: string[];
};

/**
 * Describes the message oaiproto.aisre.NotebookServiceExecuteCellsRequest.
 * Use `create(NotebookServiceExecuteCellsRequestSchema)` to create a new message.
 */
export declare const NotebookServiceExecuteCellsRequestSchema: GenMessage<NotebookServiceExecuteCellsRequest>;

/**
 * @generated from message oaiproto.aisre.NotebookServiceExecuteCellsResponse
 */
export declare type NotebookServiceExecuteCellsResponse = Message<"oaiproto.aisre.NotebookServiceExecuteCellsResponse"> & {
  /**
   * Cells contains the cells that were executed
   *
   * @generated from field: repeated runme.parser.v1.Cell cells = 1;
   */
  cells: Cell[];
};

/**
 * Describes the message oaiproto.aisre.NotebookServiceExecuteCellsResponse.
 * Use `create(NotebookServiceExecuteCellsResponseSchema)` to create a new message.
 */
export declare const NotebookServiceExecuteCellsResponseSchema: GenMessage<NotebookServiceExecuteCellsResponse>;

/**
 * @generated from message oaiproto.aisre.TerminateRunRequest
 */
export declare type TerminateRunRequest = Message<"oaiproto.aisre.TerminateRunRequest"> & {
};

/**
 * Describes the message oaiproto.aisre.TerminateRunRequest.
 * Use `create(TerminateRunRequestSchema)` to create a new message.
 */
export declare const TerminateRunRequestSchema: GenMessage<TerminateRunRequest>;

/**
 * @generated from message oaiproto.aisre.TerminateRunResponse
 */
export declare type TerminateRunResponse = Message<"oaiproto.aisre.TerminateRunResponse"> & {
};

/**
 * Describes the message oaiproto.aisre.TerminateRunResponse.
 * Use `create(TerminateRunResponseSchema)` to create a new message.
 */
export declare const TerminateRunResponseSchema: GenMessage<TerminateRunResponse>;

/**
 * ToolCallInput/ToolCallOutput are used by the backend to send/receive toolcalls from chatkit.
 * We bundle in the call_id and previous_response_id and send them to the client
 * so that the client can send them back.
 *
 * While "call_id" is part of ClientToolCallItem in chatkit's data model it doesn't seem to get
 * passed around on the client and back to the server so we handle it ourselves.
 *
 * @generated from message oaiproto.aisre.ToolCallInput
 */
export declare type ToolCallInput = Message<"oaiproto.aisre.ToolCallInput"> & {
  /**
   * @generated from field: string call_id = 1;
   */
  callId: string;

  /**
   * @generated from field: string previous_response_id = 2;
   */
  previousResponseId: string;

  /**
   * @generated from oneof oaiproto.aisre.ToolCallInput.input
   */
  input: {
    /**
     * @generated from field: oaiproto.aisre.UpdateCellsRequest update_cells = 3;
     */
    value: UpdateCellsRequest;
    case: "updateCells";
  } | {
    /**
     * @generated from field: oaiproto.aisre.ListCellsRequest list_cells = 4;
     */
    value: ListCellsRequest;
    case: "listCells";
  } | {
    /**
     * @generated from field: oaiproto.aisre.GetCellsRequest get_cells = 5;
     */
    value: GetCellsRequest;
    case: "getCells";
  } | {
    /**
     * @generated from field: oaiproto.aisre.NotebookServiceExecuteCellsRequest execute_cells = 6;
     */
    value: NotebookServiceExecuteCellsRequest;
    case: "executeCells";
  } | {
    /**
     * @generated from field: oaiproto.aisre.TerminateRunRequest terminate_run = 7;
     */
    value: TerminateRunRequest;
    case: "terminateRun";
  } | {
    /**
     * @generated from field: oaiproto.aisre.SendSlackMessageRequest send_slack_message = 8;
     */
    value: SendSlackMessageRequest;
    case: "sendSlackMessage";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message oaiproto.aisre.ToolCallInput.
 * Use `create(ToolCallInputSchema)` to create a new message.
 */
export declare const ToolCallInputSchema: GenMessage<ToolCallInput>;

/**
 * @generated from message oaiproto.aisre.ToolCallOutput
 */
export declare type ToolCallOutput = Message<"oaiproto.aisre.ToolCallOutput"> & {
  /**
   * @generated from field: string call_id = 1;
   */
  callId: string;

  /**
   * @generated from field: string previous_response_id = 2;
   */
  previousResponseId: string;

  /**
   * @generated from oneof oaiproto.aisre.ToolCallOutput.output
   */
  output: {
    /**
     * @generated from field: oaiproto.aisre.UpdateCellsResponse update_cells = 3;
     */
    value: UpdateCellsResponse;
    case: "updateCells";
  } | {
    /**
     * @generated from field: oaiproto.aisre.ListCellsResponse list_cells = 4;
     */
    value: ListCellsResponse;
    case: "listCells";
  } | {
    /**
     * @generated from field: oaiproto.aisre.GetCellsResponse get_cells = 5;
     */
    value: GetCellsResponse;
    case: "getCells";
  } | {
    /**
     * @generated from field: oaiproto.aisre.NotebookServiceExecuteCellsResponse execute_cells = 8;
     */
    value: NotebookServiceExecuteCellsResponse;
    case: "executeCells";
  } | {
    /**
     * @generated from field: oaiproto.aisre.TerminateRunResponse terminate_run = 9;
     */
    value: TerminateRunResponse;
    case: "terminateRun";
  } | {
    /**
     * @generated from field: oaiproto.aisre.SendSlackMessageResponse send_slack_message = 10;
     */
    value: SendSlackMessageResponse;
    case: "sendSlackMessage";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: oaiproto.aisre.ToolCallOutput.Status status = 6;
   */
  status: ToolCallOutput_Status;

  /**
   * client_error will be an error message if the client had one.
   *
   * @generated from field: string client_error = 7;
   */
  clientError: string;
};

/**
 * Describes the message oaiproto.aisre.ToolCallOutput.
 * Use `create(ToolCallOutputSchema)` to create a new message.
 */
export declare const ToolCallOutputSchema: GenMessage<ToolCallOutput>;

/**
 * @generated from enum oaiproto.aisre.ToolCallOutput.Status
 */
export enum ToolCallOutput_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: STATUS_FAILED = 2;
   */
  FAILED = 2,
}

/**
 * Describes the enum oaiproto.aisre.ToolCallOutput.Status.
 */
export declare const ToolCallOutput_StatusSchema: GenEnum<ToolCallOutput_Status>;

/**
 * ChatkitState is used by the backend to pass state back to chatkit.
 * This avoids needing to store state on the backend because we can just have the client store it.
 *
 * @generated from message oaiproto.aisre.ChatkitState
 */
export declare type ChatkitState = Message<"oaiproto.aisre.ChatkitState"> & {
  /**
   * @generated from field: string previous_response_id = 1;
   */
  previousResponseId: string;

  /**
   * @generated from field: string thread_id = 2;
   */
  threadId: string;
};

/**
 * Describes the message oaiproto.aisre.ChatkitState.
 * Use `create(ChatkitStateSchema)` to create a new message.
 */
export declare const ChatkitStateSchema: GenMessage<ChatkitState>;

/**
 * @generated from message oaiproto.aisre.SendSlackMessageRequest
 */
export declare type SendSlackMessageRequest = Message<"oaiproto.aisre.SendSlackMessageRequest"> & {
  /**
   * @generated from field: string channel = 1;
   */
  channel: string;

  /**
   * @generated from field: string timestamp = 2;
   */
  timestamp: string;

  /**
   * @generated from field: string text = 3;
   */
  text: string;

  /**
   * @generated from field: repeated string file_ids = 4;
   */
  fileIds: string[];
};

/**
 * Describes the message oaiproto.aisre.SendSlackMessageRequest.
 * Use `create(SendSlackMessageRequestSchema)` to create a new message.
 */
export declare const SendSlackMessageRequestSchema: GenMessage<SendSlackMessageRequest>;

/**
 * @generated from message oaiproto.aisre.SendSlackMessageResponse
 */
export declare type SendSlackMessageResponse = Message<"oaiproto.aisre.SendSlackMessageResponse"> & {
  /**
   * The error if there is one
   *
   * @generated from field: string error = 1;
   */
  error: string;
};

/**
 * Describes the message oaiproto.aisre.SendSlackMessageResponse.
 * Use `create(SendSlackMessageResponseSchema)` to create a new message.
 */
export declare const SendSlackMessageResponseSchema: GenMessage<SendSlackMessageResponse>;

/**
 * NotebookService defines methods the AI can use to interact with the notebook.
 * This is used to generate JSON schemas that can be used to define tool calls (or potentially) MCP
 * server. Using https://github.com/redpanda-data/protoc-gen-go-mcp.
 *
 * use the script project/aisre/toolsgen/build.sh to build the go code with the JSONSchemas.
 *
 * It looks like only comments on the method get translated into the description.
 *
 * TODO(jlewi): We should make it UpdateCells to allow the model to update multiple cells in a
 * single call.
 *
 * @generated from service oaiproto.aisre.NotebookService
 */
export declare const NotebookService: GenService<{
  /**
   * UpdateCell updates a cell in the document.
   * Cell is the cell to create or update. To update
   * an existing cell specify the ID of that cell in the ref_id field.
   * To create a new cell leave ref_id blank.
   *
   * You can use cell.metadata["agent/summary"] to include a short summary or description of the
   * cell. You should set the description so that its useful for deciding what cells you should read
   * to answer the user's queries.
   *
   * UpdateCellResponse will include cell id and metadata of the updated cells.
   *
   * @generated from rpc oaiproto.aisre.NotebookService.UpdateCells
   */
  updateCells: {
    methodKind: "unary";
    input: typeof UpdateCellsRequestSchema;
    output: typeof UpdateCellsResponseSchema;
  },
  /**
   * GetCells fetches the cells with the given ref_ids.
   * Use this to read the contents of cells in the notebook.
   *
   * @generated from rpc oaiproto.aisre.NotebookService.GetCells
   */
  getCells: {
    methodKind: "unary";
    input: typeof GetCellsRequestSchema;
    output: typeof GetCellsResponseSchema;
  },
  /**
   * ListCells lists the cells in a notebook.
   * Important: Only the ref_id and metadata will be populated. You should use that to decide
   * which cells to read.
   *
   * @generated from rpc oaiproto.aisre.NotebookService.ListCells
   */
  listCells: {
    methodKind: "unary";
    input: typeof ListCellsRequestSchema;
    output: typeof ListCellsResponseSchema;
  },
  /**
   * ExecuteCells executes the cells with the given ids in a notebook.
   * Use UpdateCells to write commands you want to execute then call ExecuteCells to execute the
   * cells. The response will contain the cell including the outputs of execution.
   *
   * @generated from rpc oaiproto.aisre.NotebookService.ExecuteCells
   */
  executeCells: {
    methodKind: "unary";
    input: typeof NotebookServiceExecuteCellsRequestSchema;
    output: typeof NotebookServiceExecuteCellsResponseSchema;
  },
  /**
   * TerminateRun terminates the run. Call this when no further processing is necessary to handle
   * the user request.
   *
   * @generated from rpc oaiproto.aisre.NotebookService.TerminateRun
   */
  terminateRun: {
    methodKind: "unary";
    input: typeof TerminateRunRequestSchema;
    output: typeof TerminateRunResponseSchema;
  },
  /**
   * SlackMessageRequest sends a slack message to the user.
   * Channel is The channel to send the message to e.g. "C09DF7PL6K0".
   * Typically found in the user request denoted by "Slack channel:", "slack_channel" etc.
   * If no slack channel was included in the request, do not invoke this tool.
   *
   * timestamp it the (unique identifier) of the slack thread you want to post into e.g.
   * 1757095962.288039 (may be an int or float). Typically found in the user request denoted by
   * "Slack thread timestamp:" or "slack_thread_ts" etc, If no thread timestamp was included in the
   * request, you may omit this property which will start a new thread.`,
   *
   * text is the message that the user will see in slack.
   *  A subset of markdown is supported: `-` for bullets, *bold*, _italic_, ~strike~, `inline code`,
   *  ```multiline\ncode```, > blockquote, `<http://www.example.com|hyperlink>`. DO NOT tag @here or
   *  @channel in this message.",
   *
   * fileIDs optionally send files generated as part of the investigation to the user in slack
   * (often images). e.g. ["call_ABC", "call_DEF"]`,
   *
   * @generated from rpc oaiproto.aisre.NotebookService.SendSlackMessage
   */
  sendSlackMessage: {
    methodKind: "unary";
    input: typeof SendSlackMessageRequestSchema;
    output: typeof SendSlackMessageResponseSchema;
  },
}>;

